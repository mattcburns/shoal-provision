# 032: Error Handling and Webhooks

Status: Proposed
Owners: Provisioning Working Group
Last updated: 2025-11-05

Summary

This document defines the end-to-end error handling and webhook reliability model for the Layer 3 bare‑metal provisioner. It covers:
- A shared error taxonomy across controller, Redfish orchestration, ISO builder/serving, and in‑OS workflow steps
- How failures map to job state transitions and user‑visible diagnostics
- Robust, idempotent webhooks emitted by the maintenance OS and processed by the controller
- Retry, timeout, and backoff policies
- Observability (events, logs, metrics) and acceptance criteria

Related

- 020_Provisioner_Architecture.md
- 021_Provisioner_Controller_Service.md
- 022_Recipe_Schema_and_Validation.md
- 023_Task_ISO_Builder.md
- 024_Maintenance_OS_Build_with_bootc.md
- 025_Dispatcher_Go_Binary.md
- 026_Systemd_and_Quadlet_Orchestration.md
- 027_Embedded_OCI_Registry.md
- 028_Redfish_Operations.md
- 035_Test_Strategy.md

1. Error Taxonomy

All errors are categorized into phases with canonical step keys. The controller records these in job_events and, when terminal, in jobs.failed_step.

- Preflight (controller, synchronous with POST /jobs)
  - validation.schema: recipe failed schema validation
  - validation.server: unknown or misconfigured server_serial
  - conflict.active_job: another active job for server_serial
- ISO Build and Serve (controller worker)
  - iso.build: task.iso build failure (tool missing, disk full, invalid inputs)
  - iso.serve: task.iso cannot be served (missing file, permissions)
- Redfish Orchestration (controller worker)
  - redfish.discover: failed to locate System/Manager/VirtualMedia
  - redfish.mount.maintenance: failed to insert maintenance.iso
  - redfish.mount.task: failed to insert task.iso
  - redfish.boot-override: failed to set one-time boot to CD
  - redfish.reset: failed to reset/reboot system
  - redfish.poll: BMC/API not reachable after reset within deadline
- Runtime Workflow (maintenance OS, systemd/Quadlet)
  - workflow.partition: partition.service failed
  - workflow.image-linux: image-linux.service failed
  - workflow.bootloader-linux: bootloader-linux.service failed
  - workflow.config-drive: config-drive.service failed
  - workflow.image-windows: image-windows.service failed
  - workflow.bootloader-windows: bootloader-windows.service failed
  - workflow.dispatcher: provision-dispatcher.service failed before target start
- Webhook and Cleanup (controller)
  - webhook.wait: timeout waiting for success/failure signal
  - cleanup.unmount: eject virtual media failure
  - cleanup.reset: final reboot failure

Notes:
- The maintenance OS reports runtime workflow failures by the failing unit name; the controller maps the unit to workflow.* keys for presentation.
- Controller-originated failures use the redfish.* and iso.* keys.

2. Job State Transitions

States: queued → provisioning → (succeeded|failed) → complete

- queued → provisioning: worker lease acquired; ISO built; Redfish mount/boot initiated
- provisioning → succeeded: webhook received with status=success
- provisioning → failed: webhook received with status=failed; or controller detects terminal error (e.g., redfish.* timeout) or webhook.wait timeout
- succeeded|failed → complete: cleanup (unmount media; reboot) completes or times out (still mark complete; warnings in events)

Idempotency and recovery:
- Workers extend leases periodically; on crash or restart, another worker steals the lease after expiry and reconciles state (028).
- Redfish steps and cleanup are idempotent: repeat Insert/Eject/Reset as needed.
- Duplicate webhooks are no-ops; the controller returns 200 OK.

3. Webhook Contract

3.1 Purpose

The maintenance OS signals the terminal outcome of a job to the controller via an internal webhook. This is an at-least-once delivery with strong idempotency on the controller side.

3.2 Endpoint

- POST /api/v1/status-webhook/{server_serial}

3.3 Authentication

- Strongly recommended: shared secret header (X-Webhook-Secret) or mTLS client certificate validation.
- The secret is configured into the maintenance OS build or injected via /run/provision/recipe.env.
- The controller rejects requests without valid authentication with 401/403.

3.4 Payloads

- Success (minimal)
  - status: "success"
- Failure (minimal)
  - status: "failed"
  - failed_step: systemd unit name (e.g., "bootloader-linux.service")
- Optional fields (ignored if unknown; useful for debugging and idempotency)
  - delivery_id: unique ID (UUID string) generated by the sender for deduplication
  - task_target: systemd target name (e.g., "install-linux.target")
  - dispatcher_version: version string of the on-host dispatcher
  - schema_id: $id of recipe.schema.json
  - started_at, finished_at: RFC3339 timestamps (if available to the sender)

3.5 Idempotency and Deduplication

- maintenance OS:
  - Include delivery_id (e.g., a UUID from kernel source) to uniquely identify a notification attempt.
  - On retry, reuse the same delivery_id to avoid creating multiple records on the controller.
- controller:
  - Maintain a small per-job window (e.g., last 32 delivery_id values) for deduplication.
  - If a webhook arrives for a job already in succeeded or failed, accept and return 200 OK without changing state.

3.6 Response Contract

- 200 OK: webhook accepted (even when idempotent duplicate)
- 400: invalid payload (e.g., status missing or invalid)
- 401/403: auth failure
- 404: no active job for server_serial
- 5xx: transient server error (client may retry)

SLA:
- The controller should respond within 1 second under normal load.

4. Maintenance OS: Emission and Reliability

4.1 Emitting Success or Failure

- Success path:
  - Master target’s OnSuccess triggers provision-success.service.
- Failure path:
  - Each step service declares OnFailure=provision-failed@%n.service (templated) so the failing unit is captured as %i or %n.
  - provision-dispatcher.service also has OnFailure to report dispatcher-level failures.

4.2 Network Readiness

- provision-success/failed services should After=network-online.target and Wants=network-online.target.
- If network-online is not reached within a reasonable timeout, the units still attempt delivery and rely on retry policy (below).

4.3 Curl/HTTP Behavior (guidance)

- Use flags consistent with reliable delivery:
  - Fail on 4xx/5xx
  - Set a per-request timeout (e.g., 5–10 seconds)
  - Retry via systemd unit policy (not curl loops)
- Do not log secrets. Log status code and duration only.

4.4 Retries (systemd policy)

- Configure provision-success.service and provision-failed@.service with:
  - Restart=on-failure
  - RestartSec=10s (backoff escalated via StartLimitBurst/StartLimitIntervalSec)
  - StartLimitBurst e.g., 10 and StartLimitIntervalSec e.g., 10m to produce a bounded exponential-like backoff
- At-least-once delivery: duplicates are safe and idempotent on the controller.

4.5 Degraded Mode

- If repeated failures persist beyond StartLimit policy, the service will stop.
- Since the controller also polls for ESXi reboot events in that workflow, the system has a secondary path for cleanup; for Linux/Windows workflows, operators can inspect logs on the console if webhook cannot be delivered.

5. Controller: Reception, Validation, and State Updates

5.1 Association

- Identify the active job by server_serial with status=provisioning.
- If the payload includes job_id, cross-check that it matches the active job; otherwise reject 404 or ignore job_id in favor of server_serial mapping.

5.2 Authentication and Authorization

- Verify shared secret or mTLS identity before processing the payload.
- Do not log secrets. Log only presence and auth scheme used.

5.3 Validation

- Payload must contain status with value success or failed.
- failed_step is required when status=failed.
- Optional delivery_id: if present and seen recently for this job, short-circuit to 200 OK.

5.4 State Update

- provisioning → succeeded or provisioning → failed depending on status value
- Store failed_step if provided on failure
- Append a job_event (kind=webhook, level=info, message with summary, include delivery_id if present)
- Trigger async cleanup (unmount, reboot) and transition to complete when done

5.5 Idempotency

- If job is already in a terminal state (succeeded/failed/complete) and webhook repeats, return 200 OK and append an idempotent event.

6. Timeouts and Backoff

6.1 Controller Worker Budgets (defaults; configurable)

- Redfish mount/boot override phase: up to 20 minutes (accumulated across retries)
- Webhook wait budget:
  - Linux/Windows install: up to 120 minutes (varies with artifact size/medium)
  - Maintenance tasks (firmware): up to 30 minutes
  - ESXi (no webhook): N/A; use reboot detection polling (028)
- Cleanup (unmount/reboot): up to 10 minutes; best-effort completion

6.2 HTTP Timeouts

- Controller webhook handler: read and write timeouts ≤ 10 seconds with sane global server timeouts
- Maintenance OS webhook client (curl) per-request timeout: 5–10 seconds typical

7. Observability

7.1 Events

- Every significant action logs a job_event with:
  - time (RFC3339)
  - level (info, warn, error)
  - step (taxonomy key or unit name)
  - message (human-readable summary)
- Key events include:
  - Validation outcomes (preflight)
  - ISO build lifecycle (path, size, sha256)
  - Redfish discovery, mount, boot override, reset, and polling results
  - Webhook received (status, failed_step, delivery_id)
  - Cleanup ejections and final reset

7.2 Metrics (suggested)

- webhook_received_total{status}
- webhook_delivery_duration_seconds (maintenance OS if exported later)
- job_duration_seconds{outcome}
- job_transitions_total{from,to}
- redfish_request_duration_seconds{operation,vendor}
- iso_build_duration_seconds
- iso_size_bytes
- cleanup_duration_seconds
- controller_http_requests_total{route,code}

7.3 Logging

- Structured logs include job_id, server_serial, step, attempt, duration_ms
- Redact secrets; do not include recipe contents

8. Security

- Transport: HTTPS everywhere (controller, registry, webhook)
- Auth:
  - User API: Basic or JWT (021)
  - Webhook: shared secret or mTLS
  - Registry: Basic or anonymous pull per policy (027)
- Data at rest: consider FS-level encryption for BMC credentials; never store secrets in task.iso
- Least privilege on maintenance OS: no inbound services; egress only to controller/registry

9. Idempotency and Exactly-Once Semantics

- Delivery model: at-least-once from maintenance OS; exactly-once effect on controller via deduplication
- Controller deduplication window: per-job rolling set of delivery_id values (or last status per job if delivery_id omitted)
- Cleanup operations safe to re-run:
  - Eject media multiple times
  - Reset gracefully with fallback
  - Unset one-time boot if applicable

10. Testing Strategy

Unit tests (controller)
- Webhook handler:
  - Accepts minimal success/failure payloads
  - Requires failed_step on failure
  - Auth: rejects without secret; accepts with correct secret
  - Idempotent duplicates return 200 OK without state change
- State machine:
  - Transition paths with events recorded and failed_step propagation
- ISO and Redfish error mapping:
  - Terminal Redfish errors map to failed with correct step
  - Timeouts produce webhook.wait or redfish.poll failures

Integration tests
- End-to-end Linux workflow with a mock Redfish server and a fake maintenance OS:
  - Success path transitions and cleanup
  - Failure in each step (partition, image, bootloader) triggers templated failure unit and correct mapping
- Webhook duplication:
  - Send duplicate success/failure payloads; job remains in terminal state with 200 OK
- Controller restart:
  - During provisioning, restart controller; webhook after restart is still processed; cleanup continues
- Timeouts:
  - Suppress webhook; verify webhook.wait failure path

Maintenance OS tests (VM-based)
- provisioning dispatcher failure triggers failure webhook with dispatcher unit
- Success and failure services retry policy honored (simulate temporary network errors)

11. Acceptance Criteria

- Controller
  - Records detailed job_events with clear step keys
  - Transitions states correctly on webhook success/failure and on internal terminal errors
  - Webhook endpoint enforces auth and is idempotent for duplicate deliveries
  - Cleanup runs after terminal states and marks job complete even if some cleanup steps fail (with warnings)
- Maintenance OS
  - Success and failure webhooks are emitted reliably with retries; no secrets logged
  - Failure attribution includes the failing unit name
- Observability
  - Key metrics exported; logs correlate by job_id and server_serial
- Resilience
  - Restart of controller or workers does not orphan jobs; reconciliation resumes safely
- Documentation and tests
  - Test coverage for webhook handler, state machine transitions, and error mappings (035)
  - go run build.go validate passes after implementation

12. Implementation Notes and Defaults (configurable)

- Controller webhook secret header name: X-Webhook-Secret
- Controller deduplication window: 32 delivery_ids per job (LRU)
- Timeouts:
  - Controller webhook handler: ≤ 10s
  - Maintenance OS webhook request: 5–10s
- Retry and backoff:
  - Maintenance OS: systemd Restart=on-failure, RestartSec=10s, StartLimitIntervalSec=10m, StartLimitBurst=10
- Webhook payload compatibility:
  - Accept unknown fields; require only status and, if failed, failed_step
- Event messages:
  - Avoid multi-line messages; keep concise and structured

13. Open Questions

- Should we persist a monotonic attempt counter from the maintenance OS in the payload (in addition to delivery_id) to aid troubleshooting?
- Should the controller pro-actively poll a liveness endpoint on the maintenance OS (out of scope for current design to remain self-contained)?
- Do we want an optional “partial progress” webhook for long-running steps (e.g., imaging progress)? Current design aims to keep the maintenance OS simple.

Change Log

- v0.1 (2025-11-05): Initial error handling and webhook reliability design aligned with 020–028 series.
