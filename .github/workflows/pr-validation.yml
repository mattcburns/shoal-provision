name: PR Validation

on:
  pull_request:
    branches:
      - master
      - 'release/**'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'design/**'
      - 'plans/**'
      - 'references/**'
      - '.gitignore'
      - 'LICENSE'

permissions:
  contents: read
  pull-requests: write

jobs:
  validate:
    name: Validate Code Quality
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for accurate git checks

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'  # Match project requirements
          cache: true

      - name: Install build tools
        run: |
          echo "üì¶ Installing golangci-lint and gosec..."
          go run build.go install-tools

      - name: Check license headers
        run: |
          echo "üìã Checking AGPLv3 license headers on new/changed files..."
          
          # Get list of changed Go files in this PR
          CHANGED_FILES=$(git diff --name-only --diff-filter=A origin/master...HEAD | grep '\.go$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "‚úÖ No new Go files to check"
            exit 0
          fi
          
          MISSING_LICENSE=0
          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              # Check if file has AGPLv3 header
              if ! head -n 5 "$file" | grep -q "GNU Affero General Public License"; then
                echo "‚ùå Missing AGPLv3 license header: $file"
                MISSING_LICENSE=1
              fi
            fi
          done
          
          if [ $MISSING_LICENSE -eq 1 ]; then
            echo ""
            echo "Please add the AGPLv3 license header to new source files."
            echo "See AGENTS.md section 1.4 for the required header format."
            exit 1
          fi
          
          echo "‚úÖ All new files have proper license headers"

      - name: Check dependencies for license compatibility
        run: |
          echo "üîç Scanning dependencies for AGPLv3 compatibility..."
          
          # Extract licenses using go-licenses tool
          go install github.com/google/go-licenses@latest
          
          # Get all dependencies and their licenses
          $HOME/go/bin/go-licenses csv ./... > licenses.csv 2>&1 || true
          
          # Check for incompatible licenses (very basic check)
          # This is a starting point - enhance based on actual policy
          INCOMPATIBLE=0
          
          if grep -iE '(GPL-2|LGPL|proprietary|commercial)' licenses.csv > /dev/null 2>&1; then
            echo "‚ö†Ô∏è Found potentially incompatible licenses:"
            grep -iE '(GPL-2|LGPL|proprietary|commercial)' licenses.csv || true
            INCOMPATIBLE=1
          fi
          
          if [ $INCOMPATIBLE -eq 1 ]; then
            echo ""
            echo "‚ö†Ô∏è Warning: Some dependencies may have license compatibility issues"
            echo "Please review these manually for AGPLv3 compatibility"
            # Don't fail the build on warnings, just alert
          else
            echo "‚úÖ No obvious license compatibility issues found"
          fi

      - name: Run deadcode scan
        run: |
          echo "üîç Running deadcode analysis..."
          
          # Install deadcode if not available
          if ! command -v deadcode &> /dev/null; then
            go install golang.org/x/tools/cmd/deadcode@latest
          fi
          
          # Run deadcode scan
          DEADCODE_OUTPUT=$($HOME/go/bin/deadcode ./... 2>&1 || true)
          
          if [ -n "$DEADCODE_OUTPUT" ]; then
            echo "‚ö†Ô∏è Deadcode analysis found unreachable functions:"
            echo "$DEADCODE_OUTPUT"
            echo ""
            echo "Review AGENTS.md section 4.1 for the current allowlist and guidelines."
            echo "This is informational only and does not fail the build."
          else
            echo "‚úÖ No dead code detected"
          fi

      - name: Run full validation pipeline
        run: |
          echo "üîç Running full validation pipeline..."
          go run build.go validate

      - name: Check test coverage
        run: |
          echo "üìä Checking test coverage thresholds..."
          
          # Extract coverage percentage from coverage.out
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          
          # Set minimum coverage threshold (adjust as needed)
          MIN_COVERAGE=60
          
          echo "Current coverage: ${COVERAGE}%"
          echo "Minimum required: ${MIN_COVERAGE}%"
          
          # Compare coverage (using awk for float comparison)
          if awk -v cov="$COVERAGE" -v min="$MIN_COVERAGE" 'BEGIN {exit (cov < min) ? 0 : 1}'; then
            echo "‚ùå Coverage ${COVERAGE}% is below minimum ${MIN_COVERAGE}%"
            exit 1
          fi
          
          echo "‚úÖ Coverage threshold met"

      - name: Verify recipe schema validation
        run: |
          echo "üìã Verifying recipe schema tests..."
          
          # Run recipe schema-specific tests
          go test -v ./pkg/provisioner/... -run TestRecipeSchema || {
            echo "‚ùå Recipe schema validation failed"
            exit 1
          }
          
          echo "‚úÖ Recipe schema tests passed"

      - name: Verify Redfish mock tests
        run: |
          echo "üîå Verifying Redfish client mock tests..."
          
          # Run Redfish-specific integration tests
          go test -v ./pkg/redfish/... || {
            echo "‚ùå Redfish mock tests failed"
            exit 1
          }
          
          echo "‚úÖ Redfish tests passed"

      - name: Build smoke test artifacts
        run: |
          echo "üèóÔ∏è Building smoke test artifacts..."
          
          # Build controller binary
          go run build.go build
          
          # Build dispatcher binary (static)
          echo "Building dispatcher..."
          cd cmd/provisioner-dispatcher
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o ../../build/dispatcher-linux-amd64 .
          cd ../..
          
          # Verify binaries exist
          ls -lh build/
          
          echo "‚úÖ Smoke test artifacts built successfully"

      - name: Generate validation summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## üîç PR Validation Summary
          
          ### ‚úÖ Checks Completed
          
          - License headers verified for new files
          - Dependency license compatibility checked
          - Deadcode analysis completed
          - Full validation pipeline executed
          - Test coverage verified
          - Recipe schema validation passed
          - Redfish mock tests passed
          - Smoke test artifacts built
          
          ### üìä Metrics
          
          - **Coverage**: $(go tool cover -func=coverage.out 2>/dev/null | grep total | awk '{print $3}' || echo "N/A")
          - **Go Version**: $(go version | awk '{print $3}')
          - **Build Time**: Completed in workflow
          
          ### üìù Next Steps
          
          - Review any warnings from deadcode or license scans
          - Ensure all tests pass locally with \`go run build.go validate\`
          - Address any security warnings from gosec
          EOF

  # Additional job for building tool containers (optional, can be slow)
  container-builds:
    name: Verify Container Builds
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Only run on PRs with specific label or if container files changed
    if: |
      contains(github.event.pull_request.labels.*.name, 'containers') ||
      contains(github.event.pull_request.changed_files, 'images/')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up container tools
        run: |
          echo "üì¶ Setting up podman..."
          podman --version

      - name: Lint Dockerfiles
        run: |
          echo "üîç Linting Dockerfiles/Containerfiles..."
          
          # Install hadolint for Dockerfile linting
          wget -qO /tmp/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x /tmp/hadolint
          
          # Lint all Containerfiles
          find images/ -name 'Containerfile' -o -name 'Dockerfile' | while read -r file; do
            echo "Linting $file..."
            /tmp/hadolint "$file" || echo "‚ö†Ô∏è Linting issues in $file"
          done
          
          echo "‚úÖ Dockerfile linting complete"

      - name: Build maintenance OS image
        run: |
          echo "üèóÔ∏è Building maintenance OS bootc image..."
          
          # Build the maintenance OS container image
          podman build \
            --file images/maintenance/Containerfile \
            --tag shoal-maintenance:pr-test \
            .
          
          echo "‚úÖ Maintenance OS image built successfully"
          podman images | grep shoal-maintenance

      - name: Verify image metadata
        run: |
          echo "üîç Inspecting image metadata..."
          
          podman inspect shoal-maintenance:pr-test | jq '.[0].Config.Labels'
          
          echo "‚úÖ Image metadata verified"
